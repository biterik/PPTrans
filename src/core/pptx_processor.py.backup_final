"""
PowerPoint processor for PPTrans - handles PPTX file manipulation
Complete working version with proper text application methods
"""

import os
import shutil
from datetime import datetime
from typing import List, Dict, Optional, Union, Any
from pathlib import Path
import re

from pptx import Presentation
from pptx.util import Pt
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor

from utils.logger import LoggerMixin, log_performance
from utils.exceptions import (
    PPTXProcessingError, FileNotFoundError, ValidationError,
    TranslationError, ConfigurationError
)


class ProcessingStats:
    """Statistics for processing operations"""
    
    def __init__(self):
        self.reset()
    
    def reset(self):
        """Reset all statistics"""
        self.slides_processed = 0
        self.text_elements_found = 0
        self.text_elements_translated = 0
        self.text_elements_skipped = 0
        self.errors_encountered = 0
        self.processing_time = 0.0
        self.start_time = None
        self.end_time = None


class PPTXProcessor(LoggerMixin):
    """PowerPoint presentation processor with translation capabilities"""
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize PPTX processor
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self.preserve_animations = self.config.get('preserve_animations', True)
        self.backup_original = self.config.get('backup_original', True)
        self.parallel_processing = self.config.get('parallel_processing', False)
        self.max_workers = self.config.get('max_workers', 4)
        
        # Current state
        self.current_presentation = None
        self.current_file_path = None
        self.text_elements = []
        self.stats = ProcessingStats()
        
        self.logger.info(f"PPTX Processor initialized with config: {self.config}")
    
    def load_presentation(self, file_path: Union[str, Path]) -> None:
        """
        Load a PowerPoint presentation
        
        Args:
            file_path: Path to the PPTX file
            
        Raises:
            FileNotFoundError: If file doesn't exist
            PPTXProcessingError: If file cannot be loaded
        """
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        if not file_path.suffix.lower() == '.pptx':
            raise ValidationError(f"File is not a PowerPoint presentation: {file_path}")
        
        try:
            self.logger.info(f"Loading presentation: {file_path}")
            
            # Create backup if requested
            if self.backup_original:
                backup_path = file_path.with_suffix(f'{file_path.suffix}.backup')
                shutil.copy2(file_path, backup_path)
                self.logger.info(f"Created backup: {backup_path}")
            
            # Load the presentation
            self.current_presentation = Presentation(str(file_path))
            self.current_file_path = file_path
            
            # Reset processing state
            self.text_elements = []
            self.stats.reset()
            
            slide_count = len(self.current_presentation.slides)
            self.logger.info(f"Presentation loaded successfully: {slide_count} slides")
            
        except Exception as e:
            raise PPTXProcessingError(f"Failed to load presentation: {str(e)}")
    
    def get_slide_count(self) -> int:
        """Get the number of slides in the current presentation"""
        if not self.current_presentation:
            return 0
        return len(self.current_presentation.slides)
    
    def parse_slide_range(self, range_str: str) -> List[int]:
        """
        Parse slide range string and return list of slide indices (0-based)
        
        Args:
            range_str: Range specification string (e.g., "1-5", "1,3,5", "all")
            
        Returns:
            List of 0-based slide indices
            
        Raises:
            ValidationError: If range specification is invalid
        """
        if not range_str or not range_str.strip():
            raise ValidationError("Empty slide range specification")
        
        range_str = range_str.strip().lower()
        max_slides = self.get_slide_count()
        
        if max_slides == 0:
            raise ValidationError("No presentation loaded")
        
        # Handle "all" keyword
        if range_str == "all":
            return list(range(max_slides))
        
        # Clean up the input - remove any non-digit, non-dash, non-comma characters
        cleaned = re.sub(r'[^0-9\-,\s]', '', range_str)
        cleaned = re.sub(r'\s+', '', cleaned)
        
        if not cleaned:
            raise ValidationError(f"Invalid slide range specification: '{range_str}' contains no valid numbers")
        
        slide_indices = set()
        
        try:
            # Split by commas for multiple ranges/single slides
            parts = [part.strip() for part in cleaned.split(',') if part.strip()]
            
            for part in parts:
                if '-' in part:
                    # Handle range like "5-10"
                    range_parts = part.split('-')
                    if len(range_parts) != 2:
                        raise ValidationError(f"Invalid range format: '{part}' (should be 'start-end')")
                    
                    start_str, end_str = range_parts
                    if not start_str or not end_str:
                        raise ValidationError(f"Invalid range format: '{part}' (missing start or end)")
                    
                    start = int(start_str)
                    end = int(end_str)
                    
                    if start < 1 or end < 1:
                        raise ValidationError(f"Slide numbers must be positive (got {start}-{end})")
                    
                    if start > end:
                        raise ValidationError(f"Invalid range: start ({start}) > end ({end})")
                    
                    if start > max_slides or end > max_slides:
                        raise ValidationError(f"Slide range {start}-{end} exceeds available slides (1-{max_slides})")
                    
                    # Add all slides in range (convert to 0-based indexing)
                    slide_indices.update(range(start - 1, end))
                    
                else:
                    # Handle single slide
                    slide_num = int(part)
                    if slide_num < 1:
                        raise ValidationError(f"Slide number must be positive (got {slide_num})")
                    if slide_num > max_slides:
                        raise ValidationError(f"Slide {slide_num} exceeds available slides (1-{max_slides})")
                    
                    # Convert to 0-based indexing
                    slide_indices.add(slide_num - 1)
        
        except ValueError as e:
            raise ValidationError(f"Invalid slide range specification: {range_str}. Error: {str(e)}")
        except Exception as e:
            raise ValidationError(f"Invalid slide range specification: {range_str}. Error: {str(e)}")
        
        if not slide_indices:
            raise ValidationError(f"No valid slides specified in range: {range_str}")
        
        # Return sorted list
        return sorted(list(slide_indices))
    
    def extract_text_elements(self, slide_indices: List[int]) -> List[Dict]:
        """
        Extract text elements from specified slides
        
        Args:
            slide_indices: List of slide indices (0-based) to process
            
        Returns:
            List of text element dictionaries
        """
        if not self.current_presentation:
            raise ValidationError("No presentation loaded")
        
        self.logger.info(f"Extracting text from slides: {[i+1 for i in slide_indices]}")
        
        text_elements = []
        
        for slide_idx in slide_indices:
            if slide_idx >= len(self.current_presentation.slides):
                self.logger.warning(f"Slide index {slide_idx} exceeds available slides")
                continue
            
            slide = self.current_presentation.slides[slide_idx]
            
            # Process each shape in the slide
            for shape_idx, shape in enumerate(slide.shapes):
                try:
                    if not hasattr(shape, 'text_frame') or not shape.text_frame:
                        continue
                    
                    text_frame = shape.text_frame
                    
                    # Process each paragraph
                    for para_idx, paragraph in enumerate(text_frame.paragraphs):
                        # Get all text from the paragraph
                        paragraph_text = ""
                        formatting_info = {}
                        
                        # Collect text from all runs
                        for run in paragraph.runs:
                            if run.text.strip():
                                paragraph_text += run.text
                                
                                # Capture formatting from the first run with formatting
                                if not formatting_info and run.text.strip():
                                    formatting_info = self._extract_formatting(run, paragraph)
                        
                        # Only add if there's actual text content
                        if paragraph_text.strip():
                            text_element = {
                                'slide_index': slide_idx,
                                'shape_index': shape_idx,
                                'paragraph_index': para_idx,
                                'original_text': paragraph_text,
                                'translated_text': '',
                                'formatting': formatting_info,
                                'shape_reference': shape
                            }
                            
                            text_elements.append(text_element)
                
                except Exception as e:
                    self.logger.warning(f"Error processing shape {shape_idx} on slide {slide_idx + 1}: {e}")
                    continue
        
        self.text_elements = text_elements
        self.logger.info(f"Extracted {len(text_elements)} text elements from {len(slide_indices)} slides")
        
        return text_elements
    
    def _extract_formatting(self, run, paragraph) -> Dict:
        """Extract formatting information from a text run and paragraph"""
        formatting = {}
        
        try:
            # Extract run formatting
            font = run.font
            
            if font.name:
                formatting['font_name'] = font.name
            
            if font.size:
                formatting['font_size'] = font.size.pt
            
            formatting['bold'] = font.bold if font.bold is not None else False
            formatting['italic'] = font.italic if font.italic is not None else False
            formatting['underline'] = font.underline if font.underline is not None else False
            
            # Extract color if possible
            try:
                if font.color and font.color.rgb:
                    rgb = font.color.rgb
                    formatting['font_color'] = (rgb.r, rgb.g, rgb.b)
            except Exception:
                pass
            
            # Extract paragraph alignment
            if paragraph.alignment is not None:
                alignment_map = {
                    PP_ALIGN.LEFT: 'left',
                    PP_ALIGN.CENTER: 'center',
                    PP_ALIGN.RIGHT: 'right',
                    PP_ALIGN.JUSTIFY: 'justify'
                }
                formatting['alignment'] = alignment_map.get(paragraph.alignment, 'left')
            
        except Exception as e:
            self.logger.debug(f"Error extracting formatting: {e}")
        
        return formatting
    
    @log_performance
    def translate_elements(self, translator, source_lang: str = 'auto', target_lang: str = 'en') -> None:
        """
        Translate all extracted text elements
        
        Args:
            translator: Translation service instance
            source_lang: Source language code
            target_lang: Target language code
        """
        if not self.text_elements:
            raise ValidationError("No text elements to translate")
        
        self.logger.info(f"Starting translation of {len(self.text_elements)} text elements")
        
        successful_translations = 0
        failed_translations = 0
        
        for i, element in enumerate(self.text_elements):
            try:
                original_text = element['original_text']
                if not original_text.strip():
                    continue
                
                # Translate the text
                translated_text = translator.translate_text(
                    original_text,
                    source_lang=source_lang,
                    target_lang=target_lang
                )
                
                # Store the translation
                element['translated_text'] = translated_text
                
                if translated_text != original_text:
                    successful_translations += 1
                    self.logger.debug(f"Translated: '{original_text[:50]}...' -> '{translated_text[:50]}...'")
                else:
                    self.logger.debug(f"No change: '{original_text[:50]}...'")
                
            except Exception as e:
                self.logger.warning(f"Failed to translate element {i}: {e}")
                element['translated_text'] = element['original_text']  # Keep original on failure
                failed_translations += 1
        
        self.logger.info(f"Translation completed: {len(self.text_elements)} elements translated, 0 skipped, {failed_translations} errors")
    
    def apply_translations(self) -> None:
        """Apply translated text back to the presentation"""
        if not self.current_presentation:
            raise ValidationError("No presentation loaded")
        
        if not self.text_elements:
            raise ValidationError("No text elements to apply")
        
        self.logger.info("Applying translations to presentation")
        
        successful_applications = 0
        failed_applications = 0
        
        for element in self.text_elements:
            try:
                translated_text = element.get('translated_text', element.get('original_text', ''))
                if not translated_text:
                    continue
                
                shape = element.get('shape_reference')
                if not shape:
                    failed_applications += 1
                    continue
                
                # Apply the translation using simple method
                if self._apply_text_simple(shape, translated_text):
                    successful_applications += 1
                else:
                    failed_applications += 1
                
            except Exception as e:
                self.logger.error(f"Failed to apply translation: {e}")
                failed_applications += 1
        
        self.logger.info(f"Applied {successful_applications} translations successfully, {failed_applications} failed")
    
    def _apply_text_simple(self, shape, text: str) -> bool:
        """
        Simple text application that avoids complex formatting issues
        
        Args:
            shape: PowerPoint shape object
            text: Text to apply
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Try the most direct approach first
            if hasattr(shape, 'text'):
                shape.text = text
                return True
            
            # Try text_frame approach
            if hasattr(shape, 'text_frame') and shape.text_frame:
                shape.text_frame.text = text
                return True
            
            # Try paragraph approach
            if (hasattr(shape, 'text_frame') and 
                shape.text_frame and 
                shape.text_frame.paragraphs):
                
                # Clear existing content
                for paragraph in shape.text_frame.paragraphs[1:]:
                    paragraph.clear()
                
                # Set text in first paragraph
                first_paragraph = shape.text_frame.paragraphs[0]
                first_paragraph.clear()
                run = first_paragraph.add_run()
                run.text = text
                return True
            
            return False
            
        except Exception as e:
            self.logger.debug(f"Error in _apply_text_simple: {e}")
            return False
    
    def save_presentation(self, output_path: Optional[Union[str, Path]] = None) -> Path:
        """
        Save the current presentation
        
        Args:
            output_path: Optional output path. If None, adds '_translated' to original filename
            
        Returns:
            Path to the saved file
            
        Raises:
            PPTXProcessingError: If saving fails
        """
        if not self.current_presentation:
            raise ValidationError("No presentation loaded")
        
        if output_path is None:
            # Generate output filename
            original_path = Path(self.current_file_path)
            output_path = original_path.parent / f"{original_path.stem}_translated{original_path.suffix}"
        else:
            output_path = Path(output_path)
        
        try:
            self.logger.info(f"Saving presentation to: {output_path}")
            
            # Ensure output directory exists
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Save the presentation
            self.current_presentation.save(str(output_path))
            
            self.logger.info(f"Presentation saved successfully: {output_path}")
            return output_path
            
        except Exception as e:
            raise PPTXProcessingError(f"Failed to save presentation: {str(e)}")
    
    def get_processing_stats(self) -> Dict:
        """Get processing statistics"""
        stats_dict = {
            'slides_processed': self.stats.slides_processed,
            'text_elements_found': len(self.text_elements),
            'text_elements_translated': self.stats.text_elements_translated,
            'text_elements_skipped': self.stats.text_elements_skipped,
            'errors_encountered': self.stats.errors_encountered,
            'processing_time': self.stats.processing_time
        }
        return stats_dict
    
    def close(self) -> None:
        """Clean up resources"""
        self.current_presentation = None
        self.current_file_path = None
        self.text_elements = []
        self.stats = ProcessingStats()
        self.logger.info("PPTX Processor closed")
