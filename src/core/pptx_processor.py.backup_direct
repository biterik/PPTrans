"""
PowerPoint processing engine for PPTrans
Handles PPTX file operations while preserving formatting
"""

import os
import shutil
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple, Callable
from dataclasses import dataclass, field
from pptx import Presentation
from pptx.shapes.base import BaseShape
from pptx.text.text import TextFrame, _Paragraph, _Run
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor

from utils.logger import LoggerMixin, log_performance
from utils.exceptions import (
    PPTXProcessingError, FileOperationError, 
    ValidationError, SlideRangeError
)

@dataclass
class TextElement:
    """Represents a text element with its formatting and metadata"""
    text: str
    slide_number: int
    shape_index: int
    paragraph_index: int
    run_index: Optional[int] = None
    
    # Formatting properties
    font_name: Optional[str] = None
    font_size: Optional[int] = None
    font_bold: Optional[bool] = None
    font_italic: Optional[bool] = None
    font_underline: Optional[bool] = None
    font_color: Optional[RGBColor] = None
    alignment: Optional[PP_ALIGN] = None
    
    # Metadata
    original_text: str = field(init=False)
    translated: bool = field(default=False, init=False)
    
    def __post_init__(self):
        self.original_text = self.text

@dataclass
class ProcessingStats:
    """Statistics for PPTX processing operations"""
    total_slides: int = 0
    processed_slides: int = 0
    total_text_elements: int = 0
    translated_elements: int = 0
    skipped_elements: int = 0
    errors: int = 0
    processing_time: float = 0.0

class PPTXProcessor(LoggerMixin):
    """Advanced PowerPoint file processor with format preservation"""
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize PPTX processor
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self.preserve_animations = self.config.get('preserve_animations', True)
        self.backup_original = self.config.get('backup_original', True)
        
        # Processing state
        self.current_presentation: Optional[Presentation] = None
        self.current_file_path: Optional[str] = None
        self.text_elements: List[TextElement] = []
        self.stats = ProcessingStats()
        
        self.logger.info(f"PPTX Processor initialized with config: {self.config}")
    
    def _parse_slide_range(self, slide_range: str, max_slides: int) -> List[int]:
        """
        Parse slide range specification
        
        Args:
            slide_range: Range specification (e.g., "1-5", "1,3,5", "all")
            max_slides: Maximum number of slides in presentation
        
        Returns:
            List of slide numbers (1-based)
        
        Raises:
            SlideRangeError: If range specification is invalid
        """
        slide_range = slide_range.strip().lower()
        
        if slide_range == "all":
            return list(range(1, max_slides + 1))
        
        slide_numbers = []
        
        try:
            # Split by commas for individual slides and ranges
            parts = [part.strip() for part in slide_range.split(',')]
            
            for part in parts:
                if '-' in part:
                    # Range specification (e.g., "1-5")
                    start_str, end_str = part.split('-', 1)
                    start = int(start_str.strip())
                    end = int(end_str.strip())
                    
                    if start < 1 or end > max_slides or start > end:
                        raise ValueError(f"Invalid range: {part}")
                    
                    slide_numbers.extend(range(start, end + 1))
                else:
                    # Single slide number
                    slide_num = int(part)
                    if slide_num < 1 or slide_num > max_slides:
                        raise ValueError(f"Invalid slide number: {slide_num}")
                    slide_numbers.append(slide_num)
            
            # Remove duplicates and sort
            slide_numbers = sorted(list(set(slide_numbers)))
            
        except ValueError as e:
            raise SlideRangeError(
                f"Invalid slide range specification: {slide_range}. Error: {str(e)}",
                range_spec=slide_range,
                max_slides=max_slides
            )
        
        self.logger.debug(f"Parsed slide range '{slide_range}' -> {slide_numbers}")
        return slide_numbers
    
    def _extract_text_formatting(self, run: _Run) -> Dict[str, Any]:
        """
        Extract formatting properties from a text run
        
        Args:
            run: PowerPoint text run object
        
        Returns:
            Dictionary of formatting properties
        """
        formatting = {}
        
        try:
            font = run.font
            if font.name:
                formatting['font_name'] = font.name
            if font.size:
                formatting['font_size'] = font.size.pt
            if font.bold is not None:
                formatting['font_bold'] = font.bold
            if font.italic is not None:
                formatting['font_italic'] = font.italic
            if font.underline is not None:
                formatting['font_underline'] = font.underline
            if font.color and font.color.rgb:
                formatting['font_color'] = font.color.rgb
        except Exception as e:
            self.logger.debug(f"Error extracting font formatting: {e}")
        
        return formatting
    
    def _apply_text_formatting(self, run: _Run, formatting: Dict[str, Any]) -> None:
        """
        Apply formatting properties to a text run
        
        Args:
            run: PowerPoint text run object
            formatting: Dictionary of formatting properties to apply
        """
        try:
            font = run.font
            
            if 'font_name' in formatting:
                font.name = formatting['font_name']
            if 'font_size' in formatting:
                from pptx.util import Pt
                font.size = Pt(formatting['font_size'])
            if 'font_bold' in formatting:
                font.bold = formatting['font_bold']
            if 'font_italic' in formatting:
                font.italic = formatting['font_italic']
            if 'font_underline' in formatting:
                font.underline = formatting['font_underline']
            if 'font_color' in formatting:
                font.color.rgb = formatting['font_color']
                
        except Exception as e:
            self.logger.warning(f"Error applying text formatting: {e}")
    
    def _extract_paragraph_formatting(self, paragraph: _Paragraph) -> Dict[str, Any]:
        """
        Extract formatting properties from a paragraph
        
        Args:
            paragraph: PowerPoint paragraph object
        
        Returns:
            Dictionary of formatting properties
        """
        formatting = {}
        
        try:
            if paragraph.alignment is not None:
                formatting['alignment'] = paragraph.alignment
        except Exception as e:
            self.logger.debug(f"Error extracting paragraph formatting: {e}")
        
        return formatting
    
    def _apply_paragraph_formatting(self, paragraph: _Paragraph, formatting: Dict[str, Any]) -> None:
        """
        Apply formatting properties to a paragraph
        
        Args:
            paragraph: PowerPoint paragraph object
            formatting: Dictionary of formatting properties to apply
        """
        try:
            if 'alignment' in formatting:
                paragraph.alignment = formatting['alignment']
        except Exception as e:
            self.logger.warning(f"Error applying paragraph formatting: {e}")
    
    def _extract_text_from_shape(self, shape: BaseShape, slide_number: int, shape_index: int) -> List[TextElement]:
        """
        Extract text elements from a shape while preserving formatting
        
        Args:
            shape: PowerPoint shape object
            slide_number: Slide number (1-based)
            shape_index: Shape index within the slide
        
        Returns:
            List of text elements with formatting information
        """
        text_elements = []
        
        try:
            if not shape.has_text_frame:
                return text_elements
            
            text_frame = shape.text_frame
            
            for para_idx, paragraph in enumerate(text_frame.paragraphs):
                # Extract paragraph-level formatting
                para_formatting = self._extract_paragraph_formatting(paragraph)
                
                for run_idx, run in enumerate(paragraph.runs):
                    if run.text.strip():  # Only process non-empty text
                        # Extract run-level formatting
                        run_formatting = self._extract_text_formatting(run)
                        
                        # Create text element
                        element = TextElement(
                            text=run.text,
                            slide_number=slide_number,
                            shape_index=shape_index,
                            paragraph_index=para_idx,
                            run_index=run_idx,
                            **run_formatting,
                            **para_formatting
                        )
                        
                        text_elements.append(element)
                        
        except Exception as e:
            self.logger.error(f"Error extracting text from shape {shape_index} on slide {slide_number}: {e}")
        
        return text_elements
    
            failed_applications += 1
    
    self.logger.info(f"Applied {successful_applications} translations successfully, {failed_applications} failed")
    
    if failed_applications > 0:
        self.logger.warning(f"{failed_applications} translations could not be applied"

    def _apply_text_to_shape_simple(self, shape, translated_text: str) -> bool:
        """
        Simple text application that avoids tuple errors
        """
        try:
            if hasattr(shape, 'text'):
                shape.text = translated_text
                return True
            elif hasattr(shape, 'text_frame') and shape.text_frame:
                shape.text_frame.text = translated_text
                return True
            else:
                return False
        except Exception as e:
            self.logger.error(f"Error applying text: {e}")
            return False

    def apply_translations_simple(self) -> None:
        """
        Simple translation application method
        """
        if not self.current_presentation or not self.text_elements:
            self.logger.warning("No presentation or text elements to apply")
            return
        
        self.logger.info("Applying translations to presentation (simple method)")
        
        successful = 0
        failed = 0
        
        for element in self.text_elements:
            translated_text = element.get('translated_text', element.get('original_text', ''))
            shape = element.get('shape_reference')
            
            if shape and translated_text:
                if self._apply_text_to_shape_simple(shape, translated_text):
                    successful += 1
                else:
                    failed += 1
            else:
                failed += 1
        
        self.logger.info(f"Applied {successful} translations, {failed} failed")

)